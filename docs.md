# API Reference

*Auto-generated by verus-docgenerator*

## `rational::Rational`

### Spec Functions

- **`open spec fn denom_nat`** — [rational/mod.rs:32](./src/rational/mod.rs#L32)
- **`open spec fn denom`** — [rational/mod.rs:36](./src/rational/mod.rs#L36)
- **`open spec fn as_real`** — [rational/mod.rs:40](./src/rational/mod.rs#L40)
- **`open spec fn from_int_spec`** — [rational/mod.rs:44](./src/rational/mod.rs#L44)
- **`open spec fn from_frac_spec`** — [rational/mod.rs:51](./src/rational/mod.rs#L51)
  > Spec-level construction from numerator and denominator. The sign of the denominator is moved to the numerator so the effective denominator is always positive.
- **`open spec fn add_spec`** — [rational/mod.rs:99](./src/rational/mod.rs#L99)
- **`open spec fn neg_spec`** — [rational/mod.rs:120](./src/rational/mod.rs#L120)
- **`open spec fn sub_spec`** — [rational/mod.rs:131](./src/rational/mod.rs#L131)
- **`open spec fn mul_spec`** — [rational/mod.rs:143](./src/rational/mod.rs#L143)
- **`open spec fn reciprocal_spec`** — [rational/mod.rs:162](./src/rational/mod.rs#L162)
  > Spec-level reciprocal: flips numerator and denominator. Only meaningful when self.num != 0.
- **`open spec fn div_spec`** — [rational/mod.rs:175](./src/rational/mod.rs#L175)
  > Division as multiplication by reciprocal: a / b := a * inv(b). Requires b.num != 0 (ensured by callers at proof level).
- **`open spec fn signum`** — [rational/mod.rs:179](./src/rational/mod.rs#L179)
- **`open spec fn abs_spec`** — [rational/mod.rs:189](./src/rational/mod.rs#L189)
- **`open spec fn min_spec`** — [rational/mod.rs:197](./src/rational/mod.rs#L197)
- **`open spec fn max_spec`** — [rational/mod.rs:205](./src/rational/mod.rs#L205)
- **`open spec fn eqv_spec`** — [rational/mod.rs:213](./src/rational/mod.rs#L213)
- **`open spec fn le_spec`** — [rational/mod.rs:217](./src/rational/mod.rs#L217)
- **`open spec fn lt_spec`** — [rational/mod.rs:221](./src/rational/mod.rs#L221)

### Proof Functions

- **`proof fn new`** — [rational/mod.rs:61](./src/rational/mod.rs#L61)
- **`proof fn from_int`** — [rational/mod.rs:68](./src/rational/mod.rs#L68)
- **`proof fn from_frac`** — [rational/mod.rs:75](./src/rational/mod.rs#L75)
- **`proof fn zero`** — [rational/mod.rs:85](./src/rational/mod.rs#L85)
- **`proof fn one`** — [rational/mod.rs:92](./src/rational/mod.rs#L92)
- **`proof fn add`** — [rational/mod.rs:108](./src/rational/mod.rs#L108)
- **`proof fn neg`** — [rational/mod.rs:124](./src/rational/mod.rs#L124)
- **`proof fn sub`** — [rational/mod.rs:135](./src/rational/mod.rs#L135)
- **`proof fn mul`** — [rational/mod.rs:150](./src/rational/mod.rs#L150)

## `rational::applications`

### Spec Functions

- **`open spec fn det2_spec`** — [rational/applications.rs:1177](./src/rational/applications.rs#L1177)
  > det2(a, b, c, d) = a*d - b*c.
- **`open spec fn pow_spec`** — [rational/applications.rs:1804](./src/rational/applications.rs#L1804)
  > a^n by repeated multiplication.
- **`open spec fn discriminant_spec`** — [rational/applications.rs:2212](./src/rational/applications.rs#L2212)
  > discriminant(a, b, c) = b² - 4ac.

### Proof Functions

- **`proof fn lemma_min_le_left`** — [rational/applications.rs:307](./src/rational/applications.rs#L307)
  > min(a, b) ≤ a.
- **`proof fn lemma_min_le_right`** — [rational/applications.rs:325](./src/rational/applications.rs#L325)
  > min(a, b) ≤ b.
- **`proof fn lemma_max_ge_left`** — [rational/applications.rs:341](./src/rational/applications.rs#L341)
  > a ≤ max(a, b).
- **`proof fn lemma_max_ge_right`** — [rational/applications.rs:357](./src/rational/applications.rs#L357)
  > b ≤ max(a, b).
- **`proof fn lemma_min_max_sum`** — [rational/applications.rs:375](./src/rational/applications.rs#L375)
  > min(a, b) + max(a, b) ≡ a + b.
- **`proof fn lemma_min_commutative`** — [rational/applications.rs:394](./src/rational/applications.rs#L394)
  > min is commutative (up to equivalence).
- **`proof fn lemma_max_commutative`** — [rational/applications.rs:421](./src/rational/applications.rs#L421)
  > max is commutative (up to equivalence).
- **`proof fn lemma_sum_of_squares_nonneg`** — [rational/applications.rs:449](./src/rational/applications.rs#L449)
  > a*a + b*b ≥ 0 (as le_spec from zero).
- **`proof fn lemma_sum_of_squares_zero_iff`** — [rational/applications.rs:500](./src/rational/applications.rs#L500)
  > a*a + b*b ≡ 0 if and only if a ≡ 0 and b ≡ 0.
- **`proof fn lemma_sum_of_three_squares_nonneg`** — [rational/applications.rs:566](./src/rational/applications.rs#L566)
  > 3D variant: a*a + b*b + c*c ≥ 0.
- **`proof fn lemma_sum_of_three_squares_zero_iff`** — [rational/applications.rs:609](./src/rational/applications.rs#L609)
  > 3D variant: a*a + b*b + c*c ≡ 0 iff a ≡ 0 ∧ b ≡ 0 ∧ c ≡ 0.
- **`proof fn lemma_sum_of_four_squares_nonneg`** — [rational/applications.rs:710](./src/rational/applications.rs#L710)
  > a² + b² + c² + d² ≥ 0.
- **`proof fn lemma_sum_of_four_squares_zero_iff`** — [rational/applications.rs:742](./src/rational/applications.rs#L742)
  > a² + b² + c² + d² ≡ 0 ↔ a ≡ 0 ∧ b ≡ 0 ∧ c ≡ 0 ∧ d ≡ 0.
- **`proof fn lemma_sub_self`** — [rational/applications.rs:877](./src/rational/applications.rs#L877)
  > a - a ≡ 0.
- **`proof fn lemma_sub_neg`** — [rational/applications.rs:886](./src/rational/applications.rs#L886)
  > a - (-b) == a + b (structural).
- **`proof fn lemma_neg_sub`** — [rational/applications.rs:897](./src/rational/applications.rs#L897)
  > -(a - b) == b - a (structural).
- **`proof fn lemma_double`** — [rational/applications.rs:917](./src/rational/applications.rs#L917)
  > x + x ≡ 2 * x.
- **`proof fn lemma_square_of_sum`** — [rational/applications.rs:946](./src/rational/applications.rs#L946)
  > (a+b)² ≡ a² + 2ab + b².
- **`proof fn lemma_square_of_difference`** — [rational/applications.rs:1018](./src/rational/applications.rs#L1018)
  > (a-b)² ≡ a² - 2ab + b².
- **`proof fn lemma_difference_of_squares`** — [rational/applications.rs:1063](./src/rational/applications.rs#L1063)
  > a² - b² ≡ (a+b)(a-b).
- **`proof fn lemma_det2_antisymmetric`** — [rational/applications.rs:1182](./src/rational/applications.rs#L1182)
  > Swapping rows negates the determinant.
- **`proof fn lemma_det2_zero_iff_proportional`** — [rational/applications.rs:1207](./src/rational/applications.rs#L1207)
  > det2 ≡ 0 ↔ a*d ≡ b*c (collinearity).
- **`proof fn lemma_cramer2_satisfies`** — [rational/applications.rs:1218](./src/rational/applications.rs#L1218)
  > Cramer's rule: when det ≢ 0, the solution x = (d*e - b*f)/det, y = (a*f - c*e)/det satisfies a*x + b*y ≡ e and c*x + d*y ≡ f.
- **`proof fn lemma_pow_zero`** — [rational/applications.rs:1815](./src/rational/applications.rs#L1815)
  > a^0 == 1 (structural).
- **`proof fn lemma_pow_one`** — [rational/applications.rs:1821](./src/rational/applications.rs#L1821)
  > a^1 ≡ a.
- **`proof fn lemma_pow_two`** — [rational/applications.rs:1834](./src/rational/applications.rs#L1834)
  > a^2 ≡ a*a.
- **`proof fn lemma_pow_succ`** — [rational/applications.rs:1846](./src/rational/applications.rs#L1846)
  > a^(n+1) == a * a^n (structural, from definition).
- **`proof fn lemma_pow_mul`** — [rational/applications.rs:1852](./src/rational/applications.rs#L1852)
  > (a*b)^n ≡ a^n * b^n.
- **`proof fn lemma_pow_add`** — [rational/applications.rs:1929](./src/rational/applications.rs#L1929)
  > a^(m+n) ≡ a^m * a^n.
- **`proof fn lemma_pow_even_nonneg`** — [rational/applications.rs:1968](./src/rational/applications.rs#L1968)
  > 0 ≤ a^(2n).
- **`proof fn lemma_pow_positive`** — [rational/applications.rs:2005](./src/rational/applications.rs#L2005)
  > a > 0 → a^n > 0.
- **`proof fn lemma_pow_nonneg`** — [rational/applications.rs:2032](./src/rational/applications.rs#L2032)
  > a ≥ 0 → a^n ≥ 0.
- **`proof fn lemma_pow_reciprocal`** — [rational/applications.rs:2055](./src/rational/applications.rs#L2055)
  > a ≢ 0 → (a⁻¹)^n ≡ (a^n)⁻¹.
- **`proof fn lemma_pow_monotone`** — [rational/applications.rs:2129](./src/rational/applications.rs#L2129)
  > 0 ≤ a ≤ b → a^n ≤ b^n.
- **`proof fn lemma_pow_strict_monotone`** — [rational/applications.rs:2157](./src/rational/applications.rs#L2157)
  > 0 ≤ a < b ∧ n > 0 → a^n < b^n.
- **`proof fn lemma_quadratic_at_rational_root`** — [rational/applications.rs:2218](./src/rational/applications.rs#L2218)
  > If t is a rational root of ax²+bx+c, verify it satisfies the equation.
- **`proof fn lemma_quadratic_double_root`** — [rational/applications.rs:2251](./src/rational/applications.rs#L2251)
  > When disc = 0 and a ≢ 0, the double root -b/(2a) satisfies ax²+bx+c = 0.
- **`proof fn lemma_discriminant_nonneg_square`** — [rational/applications.rs:2567](./src/rational/applications.rs#L2567)
  > If a*t²+b*t+c ≡ 0 and a ≢ 0, then discriminant b²-4ac ≥ 0.
- **`proof fn lemma_add_interval`** — [rational/applications.rs:2794](./src/rational/applications.rs#L2794)
  > a ∈ [lo_a, hi_a] ∧ b ∈ [lo_b, hi_b] → a+b ∈ [lo_a+lo_b, hi_a+hi_b].
- **`proof fn lemma_mul_interval_nonneg`** — [rational/applications.rs:2810](./src/rational/applications.rs#L2810)
  > Both non-negative: a*b ∈ [lo_a*lo_b, hi_a*hi_b].
- **`proof fn lemma_interval_contains_midpoint`** — [rational/applications.rs:2831](./src/rational/applications.rs#L2831)
  > lo ≤ hi → lo ≤ midpoint(lo, hi) ≤ hi.
- **`proof fn lemma_cauchy_schwarz_2d`** — [rational/applications.rs:2871](./src/rational/applications.rs#L2871)
  > (ac + bd)² ≤ (a² + b²)(c² + d²).
- **`proof fn lemma_cauchy_schwarz_3d`** — [rational/applications.rs:3097](./src/rational/applications.rs#L3097)
  > (a*d + b*e + c*f)² ≤ (a² + b² + c²)(d² + e² + f²).

## `rational::applications::Rational`

### Proof Functions

- **`proof fn lemma_abs_nonneg`** — [rational/applications.rs:18](./src/rational/applications.rs#L18)
  > abs(a) is non-negative.
- **`proof fn lemma_abs_zero_iff`** — [rational/applications.rs:40](./src/rational/applications.rs#L40)
  > abs(a) ≡ 0 if and only if a ≡ 0.
- **`proof fn lemma_abs_neg`** — [rational/applications.rs:60](./src/rational/applications.rs#L60)
  > abs(-a) ≡ abs(a).
- **`proof fn lemma_abs_mul`** — [rational/applications.rs:100](./src/rational/applications.rs#L100)
  > abs(a * b) ≡ abs(a) * abs(b).
- **`proof fn lemma_triangle_inequality`** — [rational/applications.rs:203](./src/rational/applications.rs#L203)
  > Triangle inequality: abs(a + b) ≤ abs(a) + abs(b).  Expressed as: abs(a+b) is le_spec to abs(a).add_spec(abs(b)).

## `rational::division`

### Proof Functions

- **`proof fn lemma_convex_between`** — [rational/division.rs:198](./src/rational/division.rs#L198)
  > If a ≤ b and 0 ≤ t ≤ 1, then a ≤ a*(1-t) + b*t ≤ b.
- **`proof fn lemma_reciprocal_of_product`** — [rational/division.rs:350](./src/rational/division.rs#L350)
  > (a*b)⁻¹ ≡ a⁻¹ * b⁻¹ when a ≢ 0 and b ≢ 0.
- **`proof fn lemma_div_mul_assoc`** — [rational/division.rs:450](./src/rational/division.rs#L450)
  > b ≢ 0 → (a/b) * c ≡ (a*c) / b.
- **`proof fn lemma_div_neg_denominator`** — [rational/division.rs:480](./src/rational/division.rs#L480)
  > a ≤ b ∧ c < 0 → b/c ≤ a/c (order reversal).
- **`proof fn lemma_reciprocal_reverses_le_pos`** — [rational/division.rs:534](./src/rational/division.rs#L534)
  > Reciprocal reverses order for positive rationals: 0 < a <= b => 1/b <= 1/a.
- **`proof fn lemma_reciprocal_reverses_le_neg`** — [rational/division.rs:571](./src/rational/division.rs#L571)
  > Reciprocal reverses order for negative rationals: a <= b < 0 => 1/b <= 1/a.

## `rational::division::Rational`

### Proof Functions

- **`proof fn lemma_mul_cancel_right`** — [rational/division.rs:16](./src/rational/division.rs#L16)
  > a*c ≡ b*c ∧ c ≢ 0 → a ≡ b.
- **`proof fn lemma_mul_cancel_left`** — [rational/division.rs:52](./src/rational/division.rs#L52)
  > c*a ≡ c*b ∧ c ≢ 0 → a ≡ b.
- **`proof fn lemma_reciprocal_spec_inverse`** — [rational/division.rs:69](./src/rational/division.rs#L69)
  > Linking lemma: reciprocal_spec(a) is the multiplicative inverse of a. Returns inv == a.reciprocal_spec() with a.mul_spec(inv) ≡ 1.
- **`proof fn lemma_div_add_numerator`** — [rational/division.rs:81](./src/rational/division.rs#L81)
  > (a + b) / c ≡ a/c + b/c when c ≢ 0.
- **`proof fn lemma_div_self`** — [rational/division.rs:94](./src/rational/division.rs#L94)
  > a ≢ 0 → a / a ≡ 1.
- **`proof fn lemma_div_cancel`** — [rational/division.rs:105](./src/rational/division.rs#L105)
  > a ≢ 0 → a * (b / a) ≡ b.
- **`proof fn lemma_div_mul_cancel`** — [rational/division.rs:137](./src/rational/division.rs#L137)
  > b ≢ 0 → (a * b) / b ≡ a.
- **`proof fn lemma_div_le_monotone`** — [rational/division.rs:160](./src/rational/division.rs#L160)
  > a ≤ b ∧ c > 0 → a/c ≤ b/c.

## `rational::equivalence`

### Spec Functions

- **`open spec fn canonical_sign_spec`** — [rational/equivalence.rs:168](./src/rational/equivalence.rs#L168)
  > Canonical sign placement for rationals: denominator positive, and zero has denominator `1`.

### Proof Functions

- **`proof fn lemma_normalized_eqv_implies_equal_denom`** — [rational/equivalence.rs:84](./src/rational/equivalence.rs#L84)
- **`proof fn lemma_eqv_and_equal_denom_implies_equal_num`** — [rational/equivalence.rs:103](./src/rational/equivalence.rs#L103)
- **`proof fn lemma_normalized_eqv_implies_equal`** — [rational/equivalence.rs:129](./src/rational/equivalence.rs#L129)
  > Strongest normalization bridge currently available: normalized semantic-equality implies structural equality.
- **`proof fn lemma_normalized_zero_has_unit_denom`** — [rational/equivalence.rs:147](./src/rational/equivalence.rs#L147)
  > Normalized values use canonical zero representation.

## `rational::equivalence::Rational`

### Spec Functions

- **`open spec fn normalized_spec`** — [rational/equivalence.rs:67](./src/rational/equivalence.rs#L67)
  > Canonical normalization predicate for the model: among semantically-equivalent representations, this value has a minimal denominator.

### Proof Functions

- **`proof fn lemma_eqv_reflexive`** — [rational/equivalence.rs:13](./src/rational/equivalence.rs#L13)
- **`proof fn lemma_eqv_symmetric`** — [rational/equivalence.rs:20](./src/rational/equivalence.rs#L20)
- **`proof fn lemma_eqv_transitive`** — [rational/equivalence.rs:28](./src/rational/equivalence.rs#L28)
- **`proof fn lemma_from_int_is_normalized`** — [rational/equivalence.rs:71](./src/rational/equivalence.rs#L71)

## `rational::foundation::Rational`

### Proof Functions

- **`proof fn lemma_nat_mul_cast`** — [rational/foundation.rs:8](./src/rational/foundation.rs#L8)
- **`proof fn lemma_denom_positive`** — [rational/foundation.rs:15](./src/rational/foundation.rs#L15)
- **`proof fn lemma_eqv_zero_iff_num_zero`** — [rational/foundation.rs:25](./src/rational/foundation.rs#L25)
- **`proof fn lemma_add_denom_product`** — [rational/foundation.rs:40](./src/rational/foundation.rs#L40)
- **`proof fn lemma_add_denom_product_int`** — [rational/foundation.rs:54](./src/rational/foundation.rs#L54)
- **`proof fn lemma_mul_denom_product`** — [rational/foundation.rs:72](./src/rational/foundation.rs#L72)
- **`proof fn lemma_mul_denom_product_int`** — [rational/foundation.rs:86](./src/rational/foundation.rs#L86)
- **`proof fn lemma_sub_denom_product`** — [rational/foundation.rs:104](./src/rational/foundation.rs#L104)
- **`proof fn lemma_sub_denom_product_int`** — [rational/foundation.rs:116](./src/rational/foundation.rs#L116)

## `rational::horner::Rational`

### Spec Functions

- **`open spec fn horner_spec`** — [rational/horner.rs:12](./src/rational/horner.rs#L12)
  > General Horner evaluation: coeffs[0] + x * (coeffs[1] + x * (... + x * coeffs[n])) Computes c₀ + c₁x + c₂x² + ... + cₙxⁿ efficiently (n muls, n adds).

### Proof Functions

- **`proof fn lemma_horner_empty`** — [rational/horner.rs:25](./src/rational/horner.rs#L25)
  > horner([], x) = 0.
- **`proof fn lemma_horner_single`** — [rational/horner.rs:31](./src/rational/horner.rs#L31)
  > horner([c], x) ≡ c.
- **`proof fn lemma_horner_linear`** — [rational/horner.rs:56](./src/rational/horner.rs#L56)
  > horner([c₀, c₁], x) ≡ c₀ + c₁ * x.
- **`proof fn lemma_horner_quadratic`** — [rational/horner.rs:81](./src/rational/horner.rs#L81)
  > horner([c₀, c₁, c₂], x) ≡ c₀ + c₁x + c₂x².
- **`proof fn lemma_horner_at_zero`** — [rational/horner.rs:151](./src/rational/horner.rs#L151)
  > Evaluating at zero: horner(coeffs, 0) ≡ coeffs[0] when non-empty.

## `rational::ordering`

### Spec Functions

- **`open spec fn midpoint_spec`** — [rational/ordering.rs:433](./src/rational/ordering.rs#L433)
  > The midpoint of two rationals: (a + b) / 2.

### Proof Functions

- **`proof fn lemma_le_mul_nonneg_both`** — [rational/ordering.rs:388](./src/rational/ordering.rs#L388)
  > If 0 ≤ a ≤ b and 0 ≤ c ≤ d, then a*c ≤ b*d.
- **`proof fn lemma_cross_mul_le`** — [rational/ordering.rs:415](./src/rational/ordering.rs#L415)
  > For rationals, a ≤ b ↔ a.num * b.denom() ≤ b.num * a.denom(). (This is definitional, but exposing it as a lemma is convenient.)
- **`proof fn lemma_cross_mul_lt`** — [rational/ordering.rs:423](./src/rational/ordering.rs#L423)
  > a < b ↔ a.num * b.denom() < b.num * a.denom().
- **`proof fn lemma_midpoint_eqv_self`** — [rational/ordering.rs:439](./src/rational/ordering.rs#L439)
  > midpoint(a, a) ≡ a.
- **`proof fn lemma_midpoint_between_left`** — [rational/ordering.rs:484](./src/rational/ordering.rs#L484)
  > If a < b, then a < midpoint(a, b) (midpoint is strictly between).
- **`proof fn lemma_midpoint_between_right`** — [rational/ordering.rs:543](./src/rational/ordering.rs#L543)
  > If a < b, then midpoint(a, b) < b.
- **`proof fn lemma_pos_mul_pos`** — [rational/ordering.rs:598](./src/rational/ordering.rs#L598)
  > Positive times positive is positive.
- **`proof fn lemma_neg_mul_neg`** — [rational/ordering.rs:627](./src/rational/ordering.rs#L627)
  > Negative times negative is positive.
- **`proof fn lemma_pos_mul_neg`** — [rational/ordering.rs:653](./src/rational/ordering.rs#L653)
  > Positive times negative is negative.
- **`proof fn lemma_neg_mul_pos`** — [rational/ordering.rs:680](./src/rational/ordering.rs#L680)
  > Negative times positive is negative.
- **`proof fn lemma_zero_mul_sign`** — [rational/ordering.rs:692](./src/rational/ordering.rs#L692)
  > If either factor is zero, the product is zero.
- **`proof fn lemma_lt_add_monotone`** — [rational/ordering.rs:718](./src/rational/ordering.rs#L718)
  > Strict addition monotonicity: a < b → a + c < b + c.
- **`proof fn lemma_lt_mul_positive`** — [rational/ordering.rs:745](./src/rational/ordering.rs#L745)
  > Strict multiplication monotonicity with positive factor.
- **`proof fn lemma_lt_mul_negative`** — [rational/ordering.rs:776](./src/rational/ordering.rs#L776)
  > Strict multiplication with negative factor reverses order.
- **`proof fn lemma_lt_sub_equiv`** — [rational/ordering.rs:808](./src/rational/ordering.rs#L808)
  > a < b ↔ 0 < b - a.
- **`proof fn lemma_neg_reverses_le`** — [rational/ordering.rs:846](./src/rational/ordering.rs#L846)
  > a ≤ b → -b ≤ -a.
- **`proof fn lemma_neg_reverses_lt`** — [rational/ordering.rs:869](./src/rational/ordering.rs#L869)
  > a < b → -b < -a.
- **`proof fn lemma_sub_le_monotone_left`** — [rational/ordering.rs:890](./src/rational/ordering.rs#L890)
  > a ≤ b → a - c ≤ b - c.
- **`proof fn lemma_sub_le_monotone_right`** — [rational/ordering.rs:901](./src/rational/ordering.rs#L901)
  > a ≤ b → c - b ≤ c - a (reversal in second arg).
- **`proof fn lemma_le_add_both`** — [rational/ordering.rs:917](./src/rational/ordering.rs#L917)
  > a ≤ b ∧ c ≤ d → a + c ≤ b + d.
- **`proof fn lemma_lt_add_both`** — [rational/ordering.rs:934](./src/rational/ordering.rs#L934)
  > a < b ∧ c < d → a + c < b + d.

## `rational::ordering::Rational`

### Proof Functions

- **`proof fn lemma_lt_irreflexive`** — [rational/ordering.rs:18](./src/rational/ordering.rs#L18)
  > No rational is strictly less than itself.
- **`proof fn lemma_lt_asymmetric`** — [rational/ordering.rs:27](./src/rational/ordering.rs#L27)
  > Strict less-than is asymmetric.
- **`proof fn lemma_lt_transitive`** — [rational/ordering.rs:40](./src/rational/ordering.rs#L40)
  > Strict less-than is transitive.
- **`proof fn lemma_trichotomy`** — [rational/ordering.rs:68](./src/rational/ordering.rs#L68)
  > Exactly one of `a < b`, `a ≡ b`, `b < a` holds.
- **`proof fn lemma_le_iff_lt_or_eqv`** — [rational/ordering.rs:82](./src/rational/ordering.rs#L82)
  > le is equivalent to lt-or-eqv.
- **`proof fn lemma_lt_implies_le`** — [rational/ordering.rs:91](./src/rational/ordering.rs#L91)
  > Strict less-than implies le.
- **`proof fn lemma_eqv_implies_le`** — [rational/ordering.rs:102](./src/rational/ordering.rs#L102)
  > Equivalence implies le (in both directions).
- **`proof fn lemma_le_antisymmetric`** — [rational/ordering.rs:114](./src/rational/ordering.rs#L114)
  > Antisymmetry: le in both directions implies equivalence.
- **`proof fn lemma_le_transitive`** — [rational/ordering.rs:126](./src/rational/ordering.rs#L126)
  > le is transitive.
- **`proof fn lemma_le_lt_transitive`** — [rational/ordering.rs:147](./src/rational/ordering.rs#L147)
  > Mixed transitivity: a ≤ b ∧ b < c → a < c.
- **`proof fn lemma_lt_le_transitive`** — [rational/ordering.rs:166](./src/rational/ordering.rs#L166)
  > Mixed transitivity: a < b ∧ b ≤ c → a < c.
- **`proof fn lemma_square_nonneg`** — [rational/ordering.rs:187](./src/rational/ordering.rs#L187)
  > The square of any rational is non-negative.
- **`proof fn lemma_square_le_nonneg`** — [rational/ordering.rs:205](./src/rational/ordering.rs#L205)
  > The square of any rational is le-nonneg: from_int(0) ≤ a*a.
- **`proof fn lemma_from_int_denom`** — [rational/ordering.rs:227](./src/rational/ordering.rs#L227)
  > Helper: from_int produces denom() == 1.
- **`proof fn lemma_from_int_preserves_lt`** — [rational/ordering.rs:235](./src/rational/ordering.rs#L235)
  > Integer embedding preserves strict ordering.
- **`proof fn lemma_from_int_preserves_le`** — [rational/ordering.rs:250](./src/rational/ordering.rs#L250)
  > Integer embedding preserves non-strict ordering.
- **`proof fn lemma_from_int_injective`** — [rational/ordering.rs:261](./src/rational/ordering.rs#L261)
  > Integer embedding is injective (equivalent images implies equal inputs).
- **`proof fn lemma_from_int_add`** — [rational/ordering.rs:273](./src/rational/ordering.rs#L273)
  > Integer embedding distributes over addition.
- **`proof fn lemma_from_int_mul`** — [rational/ordering.rs:298](./src/rational/ordering.rs#L298)
  > Integer embedding distributes over multiplication.
- **`proof fn lemma_from_int_neg`** — [rational/ordering.rs:318](./src/rational/ordering.rs#L318)
  > Integer embedding distributes over negation.
- **`proof fn lemma_from_int_sub`** — [rational/ordering.rs:326](./src/rational/ordering.rs#L326)
  > Integer embedding distributes over subtraction.
- **`proof fn lemma_le_mul_nonneg`** — [rational/ordering.rs:349](./src/rational/ordering.rs#L349)
  > If a ≤ b and 0 ≤ c, then a*c ≤ b*c.

## `rational::ring_algebra::Rational`

### Proof Functions

- **`proof fn lemma_mul_commutative`** — [rational/ring_algebra.rs:13](./src/rational/ring_algebra.rs#L13)
- **`proof fn lemma_sub_is_add_neg`** — [rational/ring_algebra.rs:30](./src/rational/ring_algebra.rs#L30)
- **`proof fn lemma_neg_involution`** — [rational/ring_algebra.rs:37](./src/rational/ring_algebra.rs#L37)
- **`proof fn lemma_add_commutative`** — [rational/ring_algebra.rs:49](./src/rational/ring_algebra.rs#L49)
- **`proof fn lemma_add_associative`** — [rational/ring_algebra.rs:87](./src/rational/ring_algebra.rs#L87)
- **`proof fn lemma_add_rearrange_2x2`** — [rational/ring_algebra.rs:144](./src/rational/ring_algebra.rs#L144)
- **`proof fn lemma_neg_add`** — [rational/ring_algebra.rs:211](./src/rational/ring_algebra.rs#L211)
- **`proof fn lemma_sub_add_distributes`** — [rational/ring_algebra.rs:235](./src/rational/ring_algebra.rs#L235)
- **`proof fn lemma_sub_mul_right`** — [rational/ring_algebra.rs:298](./src/rational/ring_algebra.rs#L298)
- **`proof fn lemma_add_zero_identity`** — [rational/ring_algebra.rs:335](./src/rational/ring_algebra.rs#L335)
- **`proof fn lemma_add_inverse`** — [rational/ring_algebra.rs:374](./src/rational/ring_algebra.rs#L374)
- **`proof fn lemma_mul_one_identity`** — [rational/ring_algebra.rs:458](./src/rational/ring_algebra.rs#L458)
- **`proof fn lemma_mul_associative`** — [rational/ring_algebra.rs:493](./src/rational/ring_algebra.rs#L493)
- **`proof fn lemma_mul_zero`** — [rational/ring_algebra.rs:537](./src/rational/ring_algebra.rs#L537)
- **`proof fn lemma_mul_distributes_over_add`** — [rational/ring_algebra.rs:556](./src/rational/ring_algebra.rs#L556)
- **`proof fn lemma_mul_zero_implies_factor_zero`** — [rational/ring_algebra.rs:564](./src/rational/ring_algebra.rs#L564)
- **`proof fn lemma_mul_reciprocal_positive_num`** — [rational/ring_algebra.rs:576](./src/rational/ring_algebra.rs#L576)
- **`proof fn reciprocal_constructive`** — [rational/ring_algebra.rs:627](./src/rational/ring_algebra.rs#L627)
- **`proof fn lemma_le_add_monotone_strong`** — [rational/ring_algebra.rs:686](./src/rational/ring_algebra.rs#L686)
- **`proof fn lemma_le_add_monotone`** — [rational/ring_algebra.rs:715](./src/rational/ring_algebra.rs#L715)
- **`proof fn lemma_le_mul_monotone_nonnegative_strong`** — [rational/ring_algebra.rs:725](./src/rational/ring_algebra.rs#L725)
- **`proof fn lemma_le_mul_monotone_nonnegative`** — [rational/ring_algebra.rs:765](./src/rational/ring_algebra.rs#L765)
- **`proof fn lemma_add_right_cancel_strong`** — [rational/ring_algebra.rs:776](./src/rational/ring_algebra.rs#L776)
- **`proof fn lemma_add_right_cancel`** — [rational/ring_algebra.rs:833](./src/rational/ring_algebra.rs#L833)
- **`proof fn lemma_add_left_cancel_strong`** — [rational/ring_algebra.rs:843](./src/rational/ring_algebra.rs#L843)
- **`proof fn lemma_add_left_cancel`** — [rational/ring_algebra.rs:869](./src/rational/ring_algebra.rs#L869)
- **`proof fn lemma_add_then_sub_cancel`** — [rational/ring_algebra.rs:879](./src/rational/ring_algebra.rs#L879)
- **`proof fn lemma_sub_then_add_cancel`** — [rational/ring_algebra.rs:918](./src/rational/ring_algebra.rs#L918)
- **`proof fn lemma_sub_eqv_zero_iff_eqv`** — [rational/ring_algebra.rs:976](./src/rational/ring_algebra.rs#L976)
- **`proof fn lemma_sub_antisymmetric`** — [rational/ring_algebra.rs:1017](./src/rational/ring_algebra.rs#L1017)
- **`proof fn lemma_mul_neg_right`** — [rational/ring_algebra.rs:1038](./src/rational/ring_algebra.rs#L1038)
- **`proof fn lemma_sub_neg_both`** — [rational/ring_algebra.rs:1058](./src/rational/ring_algebra.rs#L1058)
- **`proof fn lemma_sub_self_zero_num`** — [rational/ring_algebra.rs:1105](./src/rational/ring_algebra.rs#L1105)
- **`proof fn lemma_sub_self_zero_signum`** — [rational/ring_algebra.rs:1118](./src/rational/ring_algebra.rs#L1118)
- **`proof fn lemma_mul_left_zero_num`** — [rational/ring_algebra.rs:1130](./src/rational/ring_algebra.rs#L1130)
- **`proof fn lemma_mul_right_zero_num`** — [rational/ring_algebra.rs:1153](./src/rational/ring_algebra.rs#L1153)
- **`proof fn lemma_sub_both_zero_num`** — [rational/ring_algebra.rs:1176](./src/rational/ring_algebra.rs#L1176)

## `rational::signum::Rational`

### Proof Functions

- **`proof fn lemma_eqv_signum`** — [rational/signum.rs:14](./src/rational/signum.rs#L14)
- **`proof fn lemma_signum_positive_iff`** — [rational/signum.rs:65](./src/rational/signum.rs#L65)
- **`proof fn lemma_signum_neg`** — [rational/signum.rs:76](./src/rational/signum.rs#L76)
- **`proof fn lemma_signum_negate`** — [rational/signum.rs:84](./src/rational/signum.rs#L84)
- **`proof fn lemma_signum_negative_iff`** — [rational/signum.rs:124](./src/rational/signum.rs#L124)
- **`proof fn lemma_signum_zero_iff`** — [rational/signum.rs:135](./src/rational/signum.rs#L135)
- **`proof fn lemma_signum_cases`** — [rational/signum.rs:146](./src/rational/signum.rs#L146)
- **`proof fn lemma_signum_mul`** — [rational/signum.rs:159](./src/rational/signum.rs#L159)

## `runtime_rational`

### Spec Functions

- **`open spec fn gcd_spec`** — [runtime_rational.rs:37](./src/runtime_rational.rs#L37)
  > Spec-level GCD via Euclidean algorithm on naturals.
- **`open spec fn wf_spec`** — [runtime_rational.rs:165](./src/runtime_rational.rs#L165)
  > Well-formedness predicate: the runtime witnesses are consistent with the ghost model.  The key invariant is: numerator.model@ * model@.denom() == model@.num * (denominator.model@ as int)  This relates the witness numerator/denominator to the model's num/den through cross-multiplication, allowing them to differ by a common factor.

### Exec Functions

- **`exec fn from_int`** — [runtime_rational.rs:192](./src/runtime_rational.rs#L192)
  > Construct a rational from an i64 integer value.
- **`exec fn from_frac`** — [runtime_rational.rs:222](./src/runtime_rational.rs#L222)
  > Construct a rational from a numerator/denominator pair. The sign of the denominator is normalized so the effective denominator is always positive.
- **`exec fn add`** — [runtime_rational.rs:298](./src/runtime_rational.rs#L298)
  > Addition: a/b + c/d = (a*d + c*b) / (b*d)
- **`exec fn neg`** — [runtime_rational.rs:403](./src/runtime_rational.rs#L403)
  > Negation: -(a/b) = (-a)/b
- **`exec fn sub`** — [runtime_rational.rs:450](./src/runtime_rational.rs#L450)
  > Subtraction: a/b - c/d = a/b + (-(c/d))
- **`exec fn mul`** — [runtime_rational.rs:470](./src/runtime_rational.rs#L470)
  > Multiplication: (a/b) * (c/d) = (a*c) / (b*d)
- **`exec fn signum`** — [runtime_rational.rs:535](./src/runtime_rational.rs#L535)
  > Sign of the rational: 1, -1, or 0.
- **`exec fn recip`** — [runtime_rational.rs:589](./src/runtime_rational.rs#L589)
  > Reciprocal: (a/b) -> (b/a), returns None if zero.  Note: the returned rational carries the correct ghost model but does not guarantee `wf_spec()`.  Callers that need wf should re-establish it (e.g. via a normalizing constructor).
- **`exec fn cmp`** — [runtime_rational.rs:712](./src/runtime_rational.rs#L712)
  > Comparison: returns -1, 0, or 1. Compares self and rhs by cross-multiplying: self.num * rhs.denom() vs rhs.num * self.denom()
- **`exec fn is_zero`** — [runtime_rational.rs:835](./src/runtime_rational.rs#L835)
  > Check if this rational is zero.
- **`exec fn eq`** — [runtime_rational.rs:873](./src/runtime_rational.rs#L873)
  > Verified semantic equality: true iff the two rationals represent the same value (cross-multiplication check).
- **`exec fn lt`** — [runtime_rational.rs:885](./src/runtime_rational.rs#L885)
  > Less-than comparison.
- **`exec fn le`** — [runtime_rational.rs:897](./src/runtime_rational.rs#L897)
  > Less-than-or-equal comparison.
- **`exec fn gt`** — [runtime_rational.rs:916](./src/runtime_rational.rs#L916)
  > Greater-than comparison.
- **`exec fn ge`** — [runtime_rational.rs:927](./src/runtime_rational.rs#L927)
  > Greater-than-or-equal comparison.
- **`exec fn div`** — [runtime_rational.rs:939](./src/runtime_rational.rs#L939)
  > Division: (a/b) / (c/d) = (a*d) / (b*c). Requires the divisor is nonzero.
- **`exec fn min`** — [runtime_rational.rs:1191](./src/runtime_rational.rs#L1191)
  > Minimum of two rationals.
- **`exec fn max`** — [runtime_rational.rs:1215](./src/runtime_rational.rs#L1215)
  > Maximum of two rationals.
- **`exec fn midpoint`** — [runtime_rational.rs:1239](./src/runtime_rational.rs#L1239)
  > Midpoint: (a + b) / 2.
- **`exec fn eval_linear`** — [runtime_rational.rs:1274](./src/runtime_rational.rs#L1274)
  > Evaluate linear polynomial c₀ + c₁x using Horner's method.
- **`exec fn eval_quadratic`** — [runtime_rational.rs:1289](./src/runtime_rational.rs#L1289)
  > Evaluate quadratic c₀ + c₁x + c₂x² using Horner's method: c₀ + x * (c₁ + x * c₂).
- **`exec fn eval_cubic`** — [runtime_rational.rs:1309](./src/runtime_rational.rs#L1309)
  > Evaluate cubic c₀ + c₁x + c₂x² + c₃x³ using Horner's method: c₀ + x * (c₁ + x * (c₂ + x * c₃)).

