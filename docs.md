# API Reference

*Auto-generated by verus-docgenerator*

## `rational::Rational`

### Spec Functions

- **`open spec fn denom_nat`** — [rational/mod.rs:33](./src/rational/mod.rs#L33)
  > Effective denominator as a nat (always >= 1).
- **`open spec fn denom`** — [rational/mod.rs:38](./src/rational/mod.rs#L38)
  > Effective denominator as an int (always >= 1).
- **`open spec fn as_real`** — [rational/mod.rs:43](./src/rational/mod.rs#L43)
  > Interpretation as a real number: num / denom.
- **`open spec fn from_int_spec`** — [rational/mod.rs:48](./src/rational/mod.rs#L48)
  > Construct a rational from an integer (denominator = 1).
- **`open spec fn from_frac_spec`** — [rational/mod.rs:55](./src/rational/mod.rs#L55)
  > Spec-level construction from numerator and denominator. The sign of the denominator is moved to the numerator so the effective denominator is always positive.
- **`open spec fn add_spec`** — [rational/mod.rs:109](./src/rational/mod.rs#L109)
  > Spec-level addition: a/b + c/d = (a*d + c*b) / (b*d).
- **`open spec fn neg_spec`** — [rational/mod.rs:132](./src/rational/mod.rs#L132)
  > Spec-level negation: -(a/b) = (-a)/b.
- **`open spec fn sub_spec`** — [rational/mod.rs:145](./src/rational/mod.rs#L145)
  > Spec-level subtraction: a - b = a + (-b).
- **`open spec fn mul_spec`** — [rational/mod.rs:159](./src/rational/mod.rs#L159)
  > Spec-level multiplication: (a/b) * (c/d) = (a*c) / (b*d).
- **`open spec fn reciprocal_spec`** — [rational/mod.rs:179](./src/rational/mod.rs#L179)
  > Spec-level reciprocal: flips numerator and denominator. Only meaningful when self.num != 0.
- **`open spec fn div_spec`** — [rational/mod.rs:192](./src/rational/mod.rs#L192)
  > Division as multiplication by reciprocal: a / b := a * inv(b). Requires b.num != 0 (ensured by callers at proof level).
- **`open spec fn signum`** — [rational/mod.rs:197](./src/rational/mod.rs#L197)
  > Sign of the rational: 1, -1, or 0.
- **`open spec fn abs_spec`** — [rational/mod.rs:208](./src/rational/mod.rs#L208)
  > Absolute value: |a| = a if a >= 0, else -a.
- **`open spec fn min_spec`** — [rational/mod.rs:217](./src/rational/mod.rs#L217)
  > Minimum of two rationals.
- **`open spec fn max_spec`** — [rational/mod.rs:226](./src/rational/mod.rs#L226)
  > Maximum of two rationals.
- **`open spec fn eqv_spec`** — [rational/mod.rs:235](./src/rational/mod.rs#L235)
  > Semantic equality via cross-multiplication: a/b ≡ c/d iff a*d == c*b.
- **`open spec fn le_spec`** — [rational/mod.rs:240](./src/rational/mod.rs#L240)
  > Less-than-or-equal via cross-multiplication.
- **`open spec fn lt_spec`** — [rational/mod.rs:245](./src/rational/mod.rs#L245)
  > Strict less-than via cross-multiplication.

### Proof Functions

- **`proof fn new`** — [rational/mod.rs:66](./src/rational/mod.rs#L66)
  > Construct a rational from an integer.
- **`proof fn from_int`** — [rational/mod.rs:74](./src/rational/mod.rs#L74)
  > Construct a rational from an integer (alias for `new`).
- **`proof fn from_frac`** — [rational/mod.rs:82](./src/rational/mod.rs#L82)
  > Construct a rational from a numerator and positive denominator.
- **`proof fn zero`** — [rational/mod.rs:93](./src/rational/mod.rs#L93)
  > Construct the rational number 0.
- **`proof fn one`** — [rational/mod.rs:101](./src/rational/mod.rs#L101)
  > Construct the rational number 1.
- **`proof fn add`** — [rational/mod.rs:119](./src/rational/mod.rs#L119)
  > Proof-level addition of two rationals.
- **`proof fn neg`** — [rational/mod.rs:137](./src/rational/mod.rs#L137)
  > Proof-level negation of a rational.
- **`proof fn sub`** — [rational/mod.rs:150](./src/rational/mod.rs#L150)
  > Proof-level subtraction of two rationals.
- **`proof fn mul`** — [rational/mod.rs:167](./src/rational/mod.rs#L167)
  > Proof-level multiplication of two rationals.

## `rational::applications`

### Spec Functions

- **`open spec fn det2_spec`** — [rational/applications.rs:1177](./src/rational/applications.rs#L1177)
  > det2(a, b, c, d) = a*d - b*c.
- **`open spec fn pow_spec`** — [rational/applications.rs:1804](./src/rational/applications.rs#L1804)
  > a^n by repeated multiplication.
- **`open spec fn discriminant_spec`** — [rational/applications.rs:2212](./src/rational/applications.rs#L2212)
  > discriminant(a, b, c) = b² - 4ac.

### Proof Functions

- **`proof fn lemma_min_le_left`** — [rational/applications.rs:307](./src/rational/applications.rs#L307)
  > min(a, b) ≤ a.
- **`proof fn lemma_min_le_right`** — [rational/applications.rs:325](./src/rational/applications.rs#L325)
  > min(a, b) ≤ b.
- **`proof fn lemma_max_ge_left`** — [rational/applications.rs:341](./src/rational/applications.rs#L341)
  > a ≤ max(a, b).
- **`proof fn lemma_max_ge_right`** — [rational/applications.rs:357](./src/rational/applications.rs#L357)
  > b ≤ max(a, b).
- **`proof fn lemma_min_max_sum`** — [rational/applications.rs:375](./src/rational/applications.rs#L375)
  > min(a, b) + max(a, b) ≡ a + b.
- **`proof fn lemma_min_commutative`** — [rational/applications.rs:394](./src/rational/applications.rs#L394)
  > min is commutative (up to equivalence).
- **`proof fn lemma_max_commutative`** — [rational/applications.rs:421](./src/rational/applications.rs#L421)
  > max is commutative (up to equivalence).
- **`proof fn lemma_sum_of_squares_nonneg`** — [rational/applications.rs:449](./src/rational/applications.rs#L449)
  > a*a + b*b ≥ 0 (as le_spec from zero).
- **`proof fn lemma_sum_of_squares_zero_iff`** — [rational/applications.rs:500](./src/rational/applications.rs#L500)
  > a*a + b*b ≡ 0 if and only if a ≡ 0 and b ≡ 0.
- **`proof fn lemma_sum_of_three_squares_nonneg`** — [rational/applications.rs:566](./src/rational/applications.rs#L566)
  > 3D variant: a*a + b*b + c*c ≥ 0.
- **`proof fn lemma_sum_of_three_squares_zero_iff`** — [rational/applications.rs:609](./src/rational/applications.rs#L609)
  > 3D variant: a*a + b*b + c*c ≡ 0 iff a ≡ 0 ∧ b ≡ 0 ∧ c ≡ 0.
- **`proof fn lemma_sum_of_four_squares_nonneg`** — [rational/applications.rs:710](./src/rational/applications.rs#L710)
  > a² + b² + c² + d² ≥ 0.
- **`proof fn lemma_sum_of_four_squares_zero_iff`** — [rational/applications.rs:742](./src/rational/applications.rs#L742)
  > a² + b² + c² + d² ≡ 0 ↔ a ≡ 0 ∧ b ≡ 0 ∧ c ≡ 0 ∧ d ≡ 0.
- **`proof fn lemma_sub_self`** — [rational/applications.rs:877](./src/rational/applications.rs#L877)
  > a - a ≡ 0.
- **`proof fn lemma_sub_neg`** — [rational/applications.rs:886](./src/rational/applications.rs#L886)
  > a - (-b) == a + b (structural).
- **`proof fn lemma_neg_sub`** — [rational/applications.rs:897](./src/rational/applications.rs#L897)
  > -(a - b) == b - a (structural).
- **`proof fn lemma_double`** — [rational/applications.rs:917](./src/rational/applications.rs#L917)
  > x + x ≡ 2 * x.
- **`proof fn lemma_square_of_sum`** — [rational/applications.rs:946](./src/rational/applications.rs#L946)
  > (a+b)² ≡ a² + 2ab + b².
- **`proof fn lemma_square_of_difference`** — [rational/applications.rs:1018](./src/rational/applications.rs#L1018)
  > (a-b)² ≡ a² - 2ab + b².
- **`proof fn lemma_difference_of_squares`** — [rational/applications.rs:1063](./src/rational/applications.rs#L1063)
  > a² - b² ≡ (a+b)(a-b).
- **`proof fn lemma_det2_antisymmetric`** — [rational/applications.rs:1182](./src/rational/applications.rs#L1182)
  > Swapping rows negates the determinant.
- **`proof fn lemma_det2_zero_iff_proportional`** — [rational/applications.rs:1207](./src/rational/applications.rs#L1207)
  > det2 ≡ 0 ↔ a*d ≡ b*c (collinearity).
- **`proof fn lemma_cramer2_satisfies`** — [rational/applications.rs:1218](./src/rational/applications.rs#L1218)
  > Cramer's rule: when det ≢ 0, the solution x = (d*e - b*f)/det, y = (a*f - c*e)/det satisfies a*x + b*y ≡ e and c*x + d*y ≡ f.
- **`proof fn lemma_pow_zero`** — [rational/applications.rs:1815](./src/rational/applications.rs#L1815)
  > a^0 == 1 (structural).
- **`proof fn lemma_pow_one`** — [rational/applications.rs:1821](./src/rational/applications.rs#L1821)
  > a^1 ≡ a.
- **`proof fn lemma_pow_two`** — [rational/applications.rs:1834](./src/rational/applications.rs#L1834)
  > a^2 ≡ a*a.
- **`proof fn lemma_pow_succ`** — [rational/applications.rs:1846](./src/rational/applications.rs#L1846)
  > a^(n+1) == a * a^n (structural, from definition).
- **`proof fn lemma_pow_mul`** — [rational/applications.rs:1852](./src/rational/applications.rs#L1852)
  > (a*b)^n ≡ a^n * b^n.
- **`proof fn lemma_pow_add`** — [rational/applications.rs:1929](./src/rational/applications.rs#L1929)
  > a^(m+n) ≡ a^m * a^n.
- **`proof fn lemma_pow_even_nonneg`** — [rational/applications.rs:1968](./src/rational/applications.rs#L1968)
  > 0 ≤ a^(2n).
- **`proof fn lemma_pow_positive`** — [rational/applications.rs:2005](./src/rational/applications.rs#L2005)
  > a > 0 → a^n > 0.
- **`proof fn lemma_pow_nonneg`** — [rational/applications.rs:2032](./src/rational/applications.rs#L2032)
  > a ≥ 0 → a^n ≥ 0.
- **`proof fn lemma_pow_reciprocal`** — [rational/applications.rs:2055](./src/rational/applications.rs#L2055)
  > a ≢ 0 → (a⁻¹)^n ≡ (a^n)⁻¹.
- **`proof fn lemma_pow_monotone`** — [rational/applications.rs:2129](./src/rational/applications.rs#L2129)
  > 0 ≤ a ≤ b → a^n ≤ b^n.
- **`proof fn lemma_pow_strict_monotone`** — [rational/applications.rs:2157](./src/rational/applications.rs#L2157)
  > 0 ≤ a < b ∧ n > 0 → a^n < b^n.
- **`proof fn lemma_quadratic_at_rational_root`** — [rational/applications.rs:2218](./src/rational/applications.rs#L2218)
  > If t is a rational root of ax²+bx+c, verify it satisfies the equation.
- **`proof fn lemma_quadratic_double_root`** — [rational/applications.rs:2251](./src/rational/applications.rs#L2251)
  > When disc = 0 and a ≢ 0, the double root -b/(2a) satisfies ax²+bx+c = 0.
- **`proof fn lemma_discriminant_nonneg_square`** — [rational/applications.rs:2567](./src/rational/applications.rs#L2567)
  > If a*t²+b*t+c ≡ 0 and a ≢ 0, then discriminant b²-4ac ≥ 0.
- **`proof fn lemma_add_interval`** — [rational/applications.rs:2794](./src/rational/applications.rs#L2794)
  > a ∈ [lo_a, hi_a] ∧ b ∈ [lo_b, hi_b] → a+b ∈ [lo_a+lo_b, hi_a+hi_b].
- **`proof fn lemma_mul_interval_nonneg`** — [rational/applications.rs:2810](./src/rational/applications.rs#L2810)
  > Both non-negative: a*b ∈ [lo_a*lo_b, hi_a*hi_b].
- **`proof fn lemma_interval_contains_midpoint`** — [rational/applications.rs:2831](./src/rational/applications.rs#L2831)
  > lo ≤ hi → lo ≤ midpoint(lo, hi) ≤ hi.
- **`proof fn lemma_cauchy_schwarz_2d`** — [rational/applications.rs:2871](./src/rational/applications.rs#L2871)
  > (ac + bd)² ≤ (a² + b²)(c² + d²).
- **`proof fn lemma_cauchy_schwarz_3d`** — [rational/applications.rs:3097](./src/rational/applications.rs#L3097)
  > (a*d + b*e + c*f)² ≤ (a² + b² + c²)(d² + e² + f²).

## `rational::applications::Rational`

### Proof Functions

- **`proof fn lemma_abs_nonneg`** — [rational/applications.rs:18](./src/rational/applications.rs#L18)
  > abs(a) is non-negative.
- **`proof fn lemma_abs_zero_iff`** — [rational/applications.rs:40](./src/rational/applications.rs#L40)
  > abs(a) ≡ 0 if and only if a ≡ 0.
- **`proof fn lemma_abs_neg`** — [rational/applications.rs:60](./src/rational/applications.rs#L60)
  > abs(-a) ≡ abs(a).
- **`proof fn lemma_abs_mul`** — [rational/applications.rs:100](./src/rational/applications.rs#L100)
  > abs(a * b) ≡ abs(a) * abs(b).
- **`proof fn lemma_triangle_inequality`** — [rational/applications.rs:203](./src/rational/applications.rs#L203)
  > Triangle inequality: abs(a + b) ≤ abs(a) + abs(b).  Expressed as: abs(a+b) is le_spec to abs(a).add_spec(abs(b)).

## `rational::division`

### Proof Functions

- **`proof fn lemma_convex_between`** — [rational/division.rs:198](./src/rational/division.rs#L198)
  > If a ≤ b and 0 ≤ t ≤ 1, then a ≤ a*(1-t) + b*t ≤ b.
- **`proof fn lemma_reciprocal_of_product`** — [rational/division.rs:350](./src/rational/division.rs#L350)
  > (a*b)⁻¹ ≡ a⁻¹ * b⁻¹ when a ≢ 0 and b ≢ 0.
- **`proof fn lemma_div_mul_assoc`** — [rational/division.rs:450](./src/rational/division.rs#L450)
  > b ≢ 0 → (a/b) * c ≡ (a*c) / b.
- **`proof fn lemma_div_neg_denominator`** — [rational/division.rs:480](./src/rational/division.rs#L480)
  > a ≤ b ∧ c < 0 → b/c ≤ a/c (order reversal).
- **`proof fn lemma_reciprocal_reverses_le_pos`** — [rational/division.rs:534](./src/rational/division.rs#L534)
  > Reciprocal reverses order for positive rationals: 0 < a <= b => 1/b <= 1/a.
- **`proof fn lemma_reciprocal_reverses_le_neg`** — [rational/division.rs:571](./src/rational/division.rs#L571)
  > Reciprocal reverses order for negative rationals: a <= b < 0 => 1/b <= 1/a.

## `rational::division::Rational`

### Proof Functions

- **`proof fn lemma_mul_cancel_right`** — [rational/division.rs:16](./src/rational/division.rs#L16)
  > a*c ≡ b*c ∧ c ≢ 0 → a ≡ b.
- **`proof fn lemma_mul_cancel_left`** — [rational/division.rs:52](./src/rational/division.rs#L52)
  > c*a ≡ c*b ∧ c ≢ 0 → a ≡ b.
- **`proof fn lemma_reciprocal_spec_inverse`** — [rational/division.rs:69](./src/rational/division.rs#L69)
  > Linking lemma: reciprocal_spec(a) is the multiplicative inverse of a. Returns inv == a.reciprocal_spec() with a.mul_spec(inv) ≡ 1.
- **`proof fn lemma_div_add_numerator`** — [rational/division.rs:81](./src/rational/division.rs#L81)
  > (a + b) / c ≡ a/c + b/c when c ≢ 0.
- **`proof fn lemma_div_self`** — [rational/division.rs:94](./src/rational/division.rs#L94)
  > a ≢ 0 → a / a ≡ 1.
- **`proof fn lemma_div_cancel`** — [rational/division.rs:105](./src/rational/division.rs#L105)
  > a ≢ 0 → a * (b / a) ≡ b.
- **`proof fn lemma_div_mul_cancel`** — [rational/division.rs:137](./src/rational/division.rs#L137)
  > b ≢ 0 → (a * b) / b ≡ a.
- **`proof fn lemma_div_le_monotone`** — [rational/division.rs:160](./src/rational/division.rs#L160)
  > a ≤ b ∧ c > 0 → a/c ≤ b/c.

## `rational::equivalence`

### Spec Functions

- **`open spec fn canonical_sign_spec`** — [rational/equivalence.rs:174](./src/rational/equivalence.rs#L174)
  > Canonical sign placement for rationals: denominator positive, and zero has denominator `1`.

### Proof Functions

- **`proof fn lemma_normalized_eqv_implies_equal_denom`** — [rational/equivalence.rs:89](./src/rational/equivalence.rs#L89)
  > Two normalized equivalents have equal denominators.
- **`proof fn lemma_eqv_and_equal_denom_implies_equal_num`** — [rational/equivalence.rs:109](./src/rational/equivalence.rs#L109)
  > a ≡ b with equal denominators implies equal numerators.
- **`proof fn lemma_normalized_eqv_implies_equal`** — [rational/equivalence.rs:135](./src/rational/equivalence.rs#L135)
  > Strongest normalization bridge currently available: normalized semantic-equality implies structural equality.
- **`proof fn lemma_normalized_zero_has_unit_denom`** — [rational/equivalence.rs:153](./src/rational/equivalence.rs#L153)
  > Normalized values use canonical zero representation.

## `rational::equivalence::Rational`

### Spec Functions

- **`open spec fn normalized_spec`** — [rational/equivalence.rs:70](./src/rational/equivalence.rs#L70)
  > Canonical normalization predicate for the model: among semantically-equivalent representations, this value has a minimal denominator.

### Proof Functions

- **`proof fn lemma_eqv_reflexive`** — [rational/equivalence.rs:14](./src/rational/equivalence.rs#L14)
  > a ≡ a.
- **`proof fn lemma_eqv_symmetric`** — [rational/equivalence.rs:22](./src/rational/equivalence.rs#L22)
  > a ≡ b ↔ b ≡ a.
- **`proof fn lemma_eqv_transitive`** — [rational/equivalence.rs:31](./src/rational/equivalence.rs#L31)
  > a ≡ b ∧ b ≡ c → a ≡ c.
- **`proof fn lemma_from_int_is_normalized`** — [rational/equivalence.rs:75](./src/rational/equivalence.rs#L75)
  > from_int(v) is normalized (denominator 1 is minimal).

## `rational::foundation::Rational`

### Proof Functions

- **`proof fn lemma_nat_mul_cast`** — [rational/foundation.rs:9](./src/rational/foundation.rs#L9)
  > (a * b) as int == (a as int) * (b as int) for nats.
- **`proof fn lemma_denom_positive`** — [rational/foundation.rs:17](./src/rational/foundation.rs#L17)
  > The denominator is always positive.
- **`proof fn lemma_eqv_zero_iff_num_zero`** — [rational/foundation.rs:28](./src/rational/foundation.rs#L28)
  > a ≡ 0 ↔ a.num == 0.
- **`proof fn lemma_add_denom_product`** — [rational/foundation.rs:44](./src/rational/foundation.rs#L44)
  > denom(a + b) == denom(a) * denom(b) (nat version).
- **`proof fn lemma_add_denom_product_int`** — [rational/foundation.rs:59](./src/rational/foundation.rs#L59)
  > denom(a + b) == denom(a) * denom(b) (int version).
- **`proof fn lemma_mul_denom_product`** — [rational/foundation.rs:78](./src/rational/foundation.rs#L78)
  > denom(a * b) == denom(a) * denom(b) (nat version).
- **`proof fn lemma_mul_denom_product_int`** — [rational/foundation.rs:93](./src/rational/foundation.rs#L93)
  > denom(a * b) == denom(a) * denom(b) (int version).
- **`proof fn lemma_sub_denom_product`** — [rational/foundation.rs:112](./src/rational/foundation.rs#L112)
  > denom(a - b) == denom(a) * denom(b) (nat version).
- **`proof fn lemma_sub_denom_product_int`** — [rational/foundation.rs:125](./src/rational/foundation.rs#L125)
  > denom(a - b) == denom(a) * denom(b) (int version).

## `rational::horner::Rational`

### Spec Functions

- **`open spec fn horner_spec`** — [rational/horner.rs:12](./src/rational/horner.rs#L12)
  > General Horner evaluation: coeffs[0] + x * (coeffs[1] + x * (... + x * coeffs[n])) Computes c₀ + c₁x + c₂x² + ... + cₙxⁿ efficiently (n muls, n adds).

### Proof Functions

- **`proof fn lemma_horner_empty`** — [rational/horner.rs:25](./src/rational/horner.rs#L25)
  > horner([], x) = 0.
- **`proof fn lemma_horner_single`** — [rational/horner.rs:31](./src/rational/horner.rs#L31)
  > horner([c], x) ≡ c.
- **`proof fn lemma_horner_linear`** — [rational/horner.rs:56](./src/rational/horner.rs#L56)
  > horner([c₀, c₁], x) ≡ c₀ + c₁ * x.
- **`proof fn lemma_horner_quadratic`** — [rational/horner.rs:81](./src/rational/horner.rs#L81)
  > horner([c₀, c₁, c₂], x) ≡ c₀ + c₁x + c₂x².
- **`proof fn lemma_horner_at_zero`** — [rational/horner.rs:151](./src/rational/horner.rs#L151)
  > Evaluating at zero: horner(coeffs, 0) ≡ coeffs[0] when non-empty.

## `rational::ordering`

### Spec Functions

- **`open spec fn midpoint_spec`** — [rational/ordering.rs:433](./src/rational/ordering.rs#L433)
  > The midpoint of two rationals: (a + b) / 2.

### Proof Functions

- **`proof fn lemma_le_mul_nonneg_both`** — [rational/ordering.rs:388](./src/rational/ordering.rs#L388)
  > If 0 ≤ a ≤ b and 0 ≤ c ≤ d, then a*c ≤ b*d.
- **`proof fn lemma_cross_mul_le`** — [rational/ordering.rs:415](./src/rational/ordering.rs#L415)
  > For rationals, a ≤ b ↔ a.num * b.denom() ≤ b.num * a.denom(). (This is definitional, but exposing it as a lemma is convenient.)
- **`proof fn lemma_cross_mul_lt`** — [rational/ordering.rs:423](./src/rational/ordering.rs#L423)
  > a < b ↔ a.num * b.denom() < b.num * a.denom().
- **`proof fn lemma_midpoint_eqv_self`** — [rational/ordering.rs:439](./src/rational/ordering.rs#L439)
  > midpoint(a, a) ≡ a.
- **`proof fn lemma_midpoint_between_left`** — [rational/ordering.rs:484](./src/rational/ordering.rs#L484)
  > If a < b, then a < midpoint(a, b) (midpoint is strictly between).
- **`proof fn lemma_midpoint_between_right`** — [rational/ordering.rs:543](./src/rational/ordering.rs#L543)
  > If a < b, then midpoint(a, b) < b.
- **`proof fn lemma_pos_mul_pos`** — [rational/ordering.rs:598](./src/rational/ordering.rs#L598)
  > Positive times positive is positive.
- **`proof fn lemma_neg_mul_neg`** — [rational/ordering.rs:627](./src/rational/ordering.rs#L627)
  > Negative times negative is positive.
- **`proof fn lemma_pos_mul_neg`** — [rational/ordering.rs:653](./src/rational/ordering.rs#L653)
  > Positive times negative is negative.
- **`proof fn lemma_neg_mul_pos`** — [rational/ordering.rs:680](./src/rational/ordering.rs#L680)
  > Negative times positive is negative.
- **`proof fn lemma_zero_mul_sign`** — [rational/ordering.rs:692](./src/rational/ordering.rs#L692)
  > If either factor is zero, the product is zero.
- **`proof fn lemma_lt_add_monotone`** — [rational/ordering.rs:718](./src/rational/ordering.rs#L718)
  > Strict addition monotonicity: a < b → a + c < b + c.
- **`proof fn lemma_lt_mul_positive`** — [rational/ordering.rs:745](./src/rational/ordering.rs#L745)
  > Strict multiplication monotonicity with positive factor.
- **`proof fn lemma_lt_mul_negative`** — [rational/ordering.rs:776](./src/rational/ordering.rs#L776)
  > Strict multiplication with negative factor reverses order.
- **`proof fn lemma_lt_sub_equiv`** — [rational/ordering.rs:808](./src/rational/ordering.rs#L808)
  > a < b ↔ 0 < b - a.
- **`proof fn lemma_neg_reverses_le`** — [rational/ordering.rs:846](./src/rational/ordering.rs#L846)
  > a ≤ b → -b ≤ -a.
- **`proof fn lemma_neg_reverses_lt`** — [rational/ordering.rs:869](./src/rational/ordering.rs#L869)
  > a < b → -b < -a.
- **`proof fn lemma_sub_le_monotone_left`** — [rational/ordering.rs:890](./src/rational/ordering.rs#L890)
  > a ≤ b → a - c ≤ b - c.
- **`proof fn lemma_sub_le_monotone_right`** — [rational/ordering.rs:901](./src/rational/ordering.rs#L901)
  > a ≤ b → c - b ≤ c - a (reversal in second arg).
- **`proof fn lemma_le_add_both`** — [rational/ordering.rs:917](./src/rational/ordering.rs#L917)
  > a ≤ b ∧ c ≤ d → a + c ≤ b + d.
- **`proof fn lemma_lt_add_both`** — [rational/ordering.rs:934](./src/rational/ordering.rs#L934)
  > a < b ∧ c < d → a + c < b + d.

## `rational::ordering::Rational`

### Proof Functions

- **`proof fn lemma_lt_irreflexive`** — [rational/ordering.rs:18](./src/rational/ordering.rs#L18)
  > No rational is strictly less than itself.
- **`proof fn lemma_lt_asymmetric`** — [rational/ordering.rs:27](./src/rational/ordering.rs#L27)
  > Strict less-than is asymmetric.
- **`proof fn lemma_lt_transitive`** — [rational/ordering.rs:40](./src/rational/ordering.rs#L40)
  > Strict less-than is transitive.
- **`proof fn lemma_trichotomy`** — [rational/ordering.rs:68](./src/rational/ordering.rs#L68)
  > Exactly one of `a < b`, `a ≡ b`, `b < a` holds.
- **`proof fn lemma_le_iff_lt_or_eqv`** — [rational/ordering.rs:82](./src/rational/ordering.rs#L82)
  > le is equivalent to lt-or-eqv.
- **`proof fn lemma_lt_implies_le`** — [rational/ordering.rs:91](./src/rational/ordering.rs#L91)
  > Strict less-than implies le.
- **`proof fn lemma_eqv_implies_le`** — [rational/ordering.rs:102](./src/rational/ordering.rs#L102)
  > Equivalence implies le (in both directions).
- **`proof fn lemma_le_antisymmetric`** — [rational/ordering.rs:114](./src/rational/ordering.rs#L114)
  > Antisymmetry: le in both directions implies equivalence.
- **`proof fn lemma_le_transitive`** — [rational/ordering.rs:126](./src/rational/ordering.rs#L126)
  > le is transitive.
- **`proof fn lemma_le_lt_transitive`** — [rational/ordering.rs:147](./src/rational/ordering.rs#L147)
  > Mixed transitivity: a ≤ b ∧ b < c → a < c.
- **`proof fn lemma_lt_le_transitive`** — [rational/ordering.rs:166](./src/rational/ordering.rs#L166)
  > Mixed transitivity: a < b ∧ b ≤ c → a < c.
- **`proof fn lemma_square_nonneg`** — [rational/ordering.rs:187](./src/rational/ordering.rs#L187)
  > The square of any rational is non-negative.
- **`proof fn lemma_square_le_nonneg`** — [rational/ordering.rs:205](./src/rational/ordering.rs#L205)
  > The square of any rational is le-nonneg: from_int(0) ≤ a*a.
- **`proof fn lemma_from_int_denom`** — [rational/ordering.rs:227](./src/rational/ordering.rs#L227)
  > Helper: from_int produces denom() == 1.
- **`proof fn lemma_from_int_preserves_lt`** — [rational/ordering.rs:235](./src/rational/ordering.rs#L235)
  > Integer embedding preserves strict ordering.
- **`proof fn lemma_from_int_preserves_le`** — [rational/ordering.rs:250](./src/rational/ordering.rs#L250)
  > Integer embedding preserves non-strict ordering.
- **`proof fn lemma_from_int_injective`** — [rational/ordering.rs:261](./src/rational/ordering.rs#L261)
  > Integer embedding is injective (equivalent images implies equal inputs).
- **`proof fn lemma_from_int_add`** — [rational/ordering.rs:273](./src/rational/ordering.rs#L273)
  > Integer embedding distributes over addition.
- **`proof fn lemma_from_int_mul`** — [rational/ordering.rs:298](./src/rational/ordering.rs#L298)
  > Integer embedding distributes over multiplication.
- **`proof fn lemma_from_int_neg`** — [rational/ordering.rs:318](./src/rational/ordering.rs#L318)
  > Integer embedding distributes over negation.
- **`proof fn lemma_from_int_sub`** — [rational/ordering.rs:326](./src/rational/ordering.rs#L326)
  > Integer embedding distributes over subtraction.
- **`proof fn lemma_le_mul_nonneg`** — [rational/ordering.rs:349](./src/rational/ordering.rs#L349)
  > If a ≤ b and 0 ≤ c, then a*c ≤ b*c.

## `rational::ring_algebra::Rational`

### Proof Functions

- **`proof fn lemma_mul_commutative`** — [rational/ring_algebra.rs:14](./src/rational/ring_algebra.rs#L14)
  > a * b == b * a (structural equality).
- **`proof fn lemma_sub_is_add_neg`** — [rational/ring_algebra.rs:32](./src/rational/ring_algebra.rs#L32)
  > a - b == a + (-b) (structural equality).
- **`proof fn lemma_neg_involution`** — [rational/ring_algebra.rs:40](./src/rational/ring_algebra.rs#L40)
  > -(-a) == a (structural equality).
- **`proof fn lemma_add_commutative`** — [rational/ring_algebra.rs:53](./src/rational/ring_algebra.rs#L53)
  > a + b ≡ b + a.
- **`proof fn lemma_add_associative`** — [rational/ring_algebra.rs:92](./src/rational/ring_algebra.rs#L92)
  > (a + b) + c ≡ a + (b + c).
- **`proof fn lemma_add_rearrange_2x2`** — [rational/ring_algebra.rs:150](./src/rational/ring_algebra.rs#L150)
  > (a + b) + (c + d) ≡ (a + c) + (b + d).
- **`proof fn lemma_neg_add`** — [rational/ring_algebra.rs:218](./src/rational/ring_algebra.rs#L218)
  > -(a + b) == (-a) + (-b) (structural equality).
- **`proof fn lemma_sub_add_distributes`** — [rational/ring_algebra.rs:243](./src/rational/ring_algebra.rs#L243)
  > (a + b) - (c + d) ≡ (a - c) + (b - d).
- **`proof fn lemma_sub_mul_right`** — [rational/ring_algebra.rs:307](./src/rational/ring_algebra.rs#L307)
  > (a - b) * k ≡ a*k - b*k.
- **`proof fn lemma_add_zero_identity`** — [rational/ring_algebra.rs:345](./src/rational/ring_algebra.rs#L345)
  > a + 0 == a and 0 + a == a (structural equality).
- **`proof fn lemma_add_inverse`** — [rational/ring_algebra.rs:385](./src/rational/ring_algebra.rs#L385)
  > a + (-a) ≡ 0 and (-a) + a ≡ 0.
- **`proof fn lemma_mul_one_identity`** — [rational/ring_algebra.rs:470](./src/rational/ring_algebra.rs#L470)
  > a * 1 == a and 1 * a == a (structural equality).
- **`proof fn lemma_mul_associative`** — [rational/ring_algebra.rs:506](./src/rational/ring_algebra.rs#L506)
  > (a * b) * c ≡ a * (b * c).
- **`proof fn lemma_mul_zero`** — [rational/ring_algebra.rs:551](./src/rational/ring_algebra.rs#L551)
  > a * 0 ≡ 0 and 0 * a ≡ 0.
- **`proof fn lemma_mul_distributes_over_add`** — [rational/ring_algebra.rs:571](./src/rational/ring_algebra.rs#L571)
  > a * (b + c) ≡ a*b + a*c.
- **`proof fn lemma_mul_zero_implies_factor_zero`** — [rational/ring_algebra.rs:580](./src/rational/ring_algebra.rs#L580)
  > (a * b).num == 0 → a.num == 0 or b.num == 0.
- **`proof fn lemma_mul_reciprocal_positive_num`** — [rational/ring_algebra.rs:593](./src/rational/ring_algebra.rs#L593)
  > a > 0 → a * a⁻¹ ≡ 1.
- **`proof fn reciprocal_constructive`** — [rational/ring_algebra.rs:645](./src/rational/ring_algebra.rs#L645)
  > a ≢ 0 → returns inv with a * inv ≡ 1 and inv == a.reciprocal_spec().
- **`proof fn lemma_le_add_monotone_strong`** — [rational/ring_algebra.rs:705](./src/rational/ring_algebra.rs#L705)
  > a ≤ b → a + c ≤ b + c.
- **`proof fn lemma_le_add_monotone`** — [rational/ring_algebra.rs:735](./src/rational/ring_algebra.rs#L735)
  > a ≤ b → a + c ≤ b + c (convenience wrapper).
- **`proof fn lemma_le_mul_monotone_nonnegative_strong`** — [rational/ring_algebra.rs:746](./src/rational/ring_algebra.rs#L746)
  > a ≤ b ∧ 0 ≤ c → a*c ≤ b*c.
- **`proof fn lemma_le_mul_monotone_nonnegative`** — [rational/ring_algebra.rs:787](./src/rational/ring_algebra.rs#L787)
  > a ≤ b ∧ 0 ≤ c → a*c ≤ b*c (convenience wrapper).
- **`proof fn lemma_add_right_cancel_strong`** — [rational/ring_algebra.rs:799](./src/rational/ring_algebra.rs#L799)
  > a + k ≡ b + k → a ≡ b.
- **`proof fn lemma_add_right_cancel`** — [rational/ring_algebra.rs:857](./src/rational/ring_algebra.rs#L857)
  > a + k ≡ b + k → a ≡ b (convenience wrapper).
- **`proof fn lemma_add_left_cancel_strong`** — [rational/ring_algebra.rs:868](./src/rational/ring_algebra.rs#L868)
  > k + a ≡ k + b → a ≡ b.
- **`proof fn lemma_add_left_cancel`** — [rational/ring_algebra.rs:895](./src/rational/ring_algebra.rs#L895)
  > k + a ≡ k + b → a ≡ b (convenience wrapper).
- **`proof fn lemma_add_then_sub_cancel`** — [rational/ring_algebra.rs:906](./src/rational/ring_algebra.rs#L906)
  > (a + b) - a ≡ b.
- **`proof fn lemma_sub_then_add_cancel`** — [rational/ring_algebra.rs:946](./src/rational/ring_algebra.rs#L946)
  > b + (a - b) ≡ a.
- **`proof fn lemma_sub_eqv_zero_iff_eqv`** — [rational/ring_algebra.rs:1005](./src/rational/ring_algebra.rs#L1005)
  > a - b ≡ 0 ↔ a ≡ b.
- **`proof fn lemma_sub_antisymmetric`** — [rational/ring_algebra.rs:1047](./src/rational/ring_algebra.rs#L1047)
  > a - b == -(b - a) (structural equality).
- **`proof fn lemma_mul_neg_right`** — [rational/ring_algebra.rs:1069](./src/rational/ring_algebra.rs#L1069)
  > a * (-b) == -(a * b) (structural equality).
- **`proof fn lemma_sub_neg_both`** — [rational/ring_algebra.rs:1090](./src/rational/ring_algebra.rs#L1090)
  > (-a) - (-b) == -(a - b) (structural equality).
- **`proof fn lemma_sub_self_zero_num`** — [rational/ring_algebra.rs:1138](./src/rational/ring_algebra.rs#L1138)
  > (a - a).num == 0.
- **`proof fn lemma_sub_self_zero_signum`** — [rational/ring_algebra.rs:1152](./src/rational/ring_algebra.rs#L1152)
  > signum(a - a) == 0.
- **`proof fn lemma_mul_left_zero_num`** — [rational/ring_algebra.rs:1165](./src/rational/ring_algebra.rs#L1165)
  > a.num == 0 → (a * b).num == 0.
- **`proof fn lemma_mul_right_zero_num`** — [rational/ring_algebra.rs:1189](./src/rational/ring_algebra.rs#L1189)
  > b.num == 0 → (a * b).num == 0.
- **`proof fn lemma_sub_both_zero_num`** — [rational/ring_algebra.rs:1213](./src/rational/ring_algebra.rs#L1213)
  > a.num == 0 ∧ b.num == 0 → (a - b).num == 0.

## `rational::signum::Rational`

### Proof Functions

- **`proof fn lemma_eqv_signum`** — [rational/signum.rs:15](./src/rational/signum.rs#L15)
  > a ≡ b → signum(a) == signum(b).
- **`proof fn lemma_signum_positive_iff`** — [rational/signum.rs:67](./src/rational/signum.rs#L67)
  > signum(a) == 1 ↔ a.num > 0.
- **`proof fn lemma_signum_neg`** — [rational/signum.rs:79](./src/rational/signum.rs#L79)
  > (-a).num == -a.num.
- **`proof fn lemma_signum_negate`** — [rational/signum.rs:88](./src/rational/signum.rs#L88)
  > signum(-a) == -signum(a).
- **`proof fn lemma_signum_negative_iff`** — [rational/signum.rs:129](./src/rational/signum.rs#L129)
  > signum(a) == -1 ↔ a.num < 0.
- **`proof fn lemma_signum_zero_iff`** — [rational/signum.rs:141](./src/rational/signum.rs#L141)
  > signum(a) == 0 ↔ a.num == 0.
- **`proof fn lemma_signum_cases`** — [rational/signum.rs:153](./src/rational/signum.rs#L153)
  > signum(a) is always 1, -1, or 0.
- **`proof fn lemma_signum_mul`** — [rational/signum.rs:167](./src/rational/signum.rs#L167)
  > signum(a * b) == signum(a) * signum(b).

## `runtime_rational`

### Spec Functions

- **`open spec fn gcd_spec`** — [runtime_rational.rs:37](./src/runtime_rational.rs#L37)
  > Spec-level GCD via Euclidean algorithm on naturals.
- **`open spec fn wf_spec`** — [runtime_rational.rs:165](./src/runtime_rational.rs#L165)
  > Well-formedness predicate: the runtime witnesses are consistent with the ghost model.  The key invariant is: numerator.model@ * model@.denom() == model@.num * (denominator.model@ as int)  This relates the witness numerator/denominator to the model's num/den through cross-multiplication, allowing them to differ by a common factor.

### Exec Functions

- **`exec fn from_int`** — [runtime_rational.rs:192](./src/runtime_rational.rs#L192)
  > Construct a rational from an i64 integer value.
- **`exec fn from_frac`** — [runtime_rational.rs:222](./src/runtime_rational.rs#L222)
  > Construct a rational from a numerator/denominator pair. The sign of the denominator is normalized so the effective denominator is always positive.
- **`exec fn add`** — [runtime_rational.rs:298](./src/runtime_rational.rs#L298)
  > Addition: a/b + c/d = (a*d + c*b) / (b*d)
- **`exec fn neg`** — [runtime_rational.rs:403](./src/runtime_rational.rs#L403)
  > Negation: -(a/b) = (-a)/b
- **`exec fn sub`** — [runtime_rational.rs:450](./src/runtime_rational.rs#L450)
  > Subtraction: a/b - c/d = a/b + (-(c/d))
- **`exec fn mul`** — [runtime_rational.rs:470](./src/runtime_rational.rs#L470)
  > Multiplication: (a/b) * (c/d) = (a*c) / (b*d)
- **`exec fn signum`** — [runtime_rational.rs:535](./src/runtime_rational.rs#L535)
  > Sign of the rational: 1, -1, or 0.
- **`exec fn recip`** — [runtime_rational.rs:589](./src/runtime_rational.rs#L589)
  > Reciprocal: (a/b) -> (b/a), returns None if zero.  Note: the returned rational carries the correct ghost model but does not guarantee `wf_spec()`.  Callers that need wf should re-establish it (e.g. via a normalizing constructor).
- **`exec fn cmp`** — [runtime_rational.rs:712](./src/runtime_rational.rs#L712)
  > Comparison: returns -1, 0, or 1. Compares self and rhs by cross-multiplying: self.num * rhs.denom() vs rhs.num * self.denom()
- **`exec fn is_zero`** — [runtime_rational.rs:835](./src/runtime_rational.rs#L835)
  > Check if this rational is zero.
- **`exec fn eq`** — [runtime_rational.rs:873](./src/runtime_rational.rs#L873)
  > Verified semantic equality: true iff the two rationals represent the same value (cross-multiplication check).
- **`exec fn lt`** — [runtime_rational.rs:885](./src/runtime_rational.rs#L885)
  > Less-than comparison.
- **`exec fn le`** — [runtime_rational.rs:897](./src/runtime_rational.rs#L897)
  > Less-than-or-equal comparison.
- **`exec fn gt`** — [runtime_rational.rs:916](./src/runtime_rational.rs#L916)
  > Greater-than comparison.
- **`exec fn ge`** — [runtime_rational.rs:927](./src/runtime_rational.rs#L927)
  > Greater-than-or-equal comparison.
- **`exec fn div`** — [runtime_rational.rs:939](./src/runtime_rational.rs#L939)
  > Division: (a/b) / (c/d) = (a*d) / (b*c). Requires the divisor is nonzero.
- **`exec fn min`** — [runtime_rational.rs:1191](./src/runtime_rational.rs#L1191)
  > Minimum of two rationals.
- **`exec fn max`** — [runtime_rational.rs:1215](./src/runtime_rational.rs#L1215)
  > Maximum of two rationals.
- **`exec fn midpoint`** — [runtime_rational.rs:1239](./src/runtime_rational.rs#L1239)
  > Midpoint: (a + b) / 2.
- **`exec fn eval_linear`** — [runtime_rational.rs:1274](./src/runtime_rational.rs#L1274)
  > Evaluate linear polynomial c₀ + c₁x using Horner's method.
- **`exec fn eval_quadratic`** — [runtime_rational.rs:1289](./src/runtime_rational.rs#L1289)
  > Evaluate quadratic c₀ + c₁x + c₂x² using Horner's method: c₀ + x * (c₁ + x * c₂).
- **`exec fn eval_cubic`** — [runtime_rational.rs:1309](./src/runtime_rational.rs#L1309)
  > Evaluate cubic c₀ + c₁x + c₂x² + c₃x³ using Horner's method: c₀ + x * (c₁ + x * (c₂ + x * c₃)).

